const coordinates = {};
const surfaces = {};

const 背位置 = { Y: 30, Z: -20 };
const 背縦 = [
  [70, -15, 0.6, 1],
  [60, -15, 0.65, 0.5],
  [50, -15, 0.7, 0],
  [30, -15, 0.8, 0],
  [10, -13, 0.9, 0],
  [5, -10, 0.95, 0],
  [0, -5, 1, 0],
  [-5, 0, 0.95, 0],
  [-10, 3, 0.9, 0],
  [-30, 5, 0.8, 0],
];
const 背横 = [
  [30, 0, 3, 0.93],
  [27, -2.5, 3, 0.96],
  [20, -4, 3, 0.98],
  [10, -6, 3, 0.995],
  [0, -7, 3, 1],
];
const 尻縦 = [
  [40, -1, 7, 1],
  [30, -0.5, 9, 0.5],
  [20, 0, 9.5, 0],
  [10, 0, 10, 0],
  [0, 0, 10, 0],
  [-10, 0, 10, 0.5],
  [-20, 0, 8, 1],
];
const 尻横 = [
  [30, 3, 0.5, 0.9],
  [27, 3, 0.8, 1],
  [20, 2, 1, 1],
  [10, 1, 0.9, 1],
  [0, 0.1, 0.8, 1],
];
const 腕縦 = [
  [30, 30.5, 2, 1],
  [25, 31.5, 2.5, 0.5],
  [20, 32, 3, 0],
  [0, 32, 3, 0],
  [-15, 32, 3, 0.5],
  [-20, 32, 2, 1],
];
const 腕横 = [
  [40, 0, 0.75, 0.9],
  [38, 0, 1, 1],
  [32, 0, 1, 1],
  [30, 0, 0.75, 0.9],
];
const 柱 = {
  幅Z: 8,
  幅X: 2,
  下Z: 0,
  横X: 34,
  径: 6,
  解像度: 4,
  角度: 10 / 180 * Math.PI,
};
const 脚 = {
  数: 5,
  外径: 45,
  内径: 8,
  外幅: 2,
  内幅: 3,
  外位: -60,
  内位: -55,
  外高: 5,
  内高: 8,
};
const 骨 = {
  解像度: 12,
  下径: 6,
  上径: 4,
  下高: 30,
};

背縦.forEach(([縦位置Y, 縦角度X, 縦位置T, 縦補正], 縦進捗) => {
  背横.forEach(([横位置X, 横位置Z, 横位置A, 横縮尺], 横進捗) => {
    [0, 1].forEach((前後係数) => {
      const 座標Y0 = 縦位置Y * (1 - (1 - 横縮尺) * 縦補正);
      const 座標Z0 = (横位置Z - 横位置A * 前後係数) * 縦位置T;
      const 距離Z0 = Math.pow(座標Y0 * 座標Y0 + 座標Z0 * 座標Z0, 1 / 2);
      const 角度Z1 = 距離Z0 ? Math.acos(座標Y0 / 距離Z0) * (座標Z0 >= 0 ? 1 : -1) + 縦角度X / 180 * Math.PI : 0;
      const 座標Y1 = Math.cos(角度Z1) * 距離Z0 + 背位置.Y;
      const 座標Z1 = Math.sin(角度Z1) * 距離Z0 + 背位置.Z;
      [1, -1].forEach((左右係数, 左右) => {
        coordinates[`SE${縦進捗}.${横進捗}.${左右}.${前後係数}`] = { X: 横位置X * 左右係数, Y: 座標Y1, Z: 座標Z1 };
        if (縦進捗 && 横進捗) {
          surfaces[`SE${縦進捗}.${横進捗}.${左右}.${前後係数}`] = [
            `SE${縦進捗 - 1}.${横進捗 - 1}.${左右}.${前後係数}`,
            `SE${縦進捗 - 1}.${横進捗}.${左右}.${前後係数}`,
            `SE${縦進捗}.${横進捗}.${左右}.${前後係数}`,
            `SE${縦進捗}.${横進捗 - 1}.${左右}.${前後係数}`,
          ];
        }
      });
    });
  });
});

尻縦.forEach(([縦位置Z, 縦位置Y, 縦位置A, 縦補正], 縦進捗) => {
  尻横.forEach(([横位置X, 横位置Y, 横補正, 横縮尺], 横進捗) => {
    const 座標Z = 縦位置Z * (1 - (1 - 横縮尺) * 縦補正);
    [0, 1].forEach((上下係数) => {
      const 座標Y = 横位置Y + 縦位置Y + (上下係数 ? 縦位置A * 横補正 : 0);
      [1, -1].forEach((左右係数, 左右) => {
        coordinates[`SI${縦進捗}.${横進捗}.${左右}.${上下係数}`] = { X: 横位置X * 左右係数, Y: 座標Y, Z: 座標Z };
        if (縦進捗 && 横進捗) {
          surfaces[`SI${縦進捗}.${横進捗}.${左右}.${上下係数}`] = [
            `SI${縦進捗 - 1}.${横進捗 - 1}.${左右}.${上下係数}`,
            `SI${縦進捗 - 1}.${横進捗}.${左右}.${上下係数}`,
            `SI${縦進捗}.${横進捗}.${左右}.${上下係数}`,
            `SI${縦進捗}.${横進捗 - 1}.${左右}.${上下係数}`,
          ];
        }
      });
    });
  });
});

腕縦.forEach(([縦位置Z, 縦位置Y, 縦位置A, 縦補正], 縦進捗) => {
  腕横.forEach(([横位置X, 横位置Y, 横補正, 横縮尺], 横進捗) => {
    const 座標Z = 縦位置Z * (1 - (1 - 横縮尺) * 縦補正);
    [0, 1].forEach((上下係数) => {
      const 座標Y = 横位置Y + 縦位置Y + (上下係数 ? 縦位置A * 横補正 : 0);
      [1, -1].forEach((左右係数, 左右) => {
        coordinates[`UD${縦進捗}.${横進捗}.${左右}.${上下係数}`] = { X: 横位置X * 左右係数, Y: 座標Y, Z: 座標Z };
        if (縦進捗 && 横進捗) {
          surfaces[`UD${縦進捗}.${横進捗}.${左右}.${上下係数}`] = [
            `UD${縦進捗 - 1}.${横進捗 - 1}.${左右}.${上下係数}`,
            `UD${縦進捗 - 1}.${横進捗}.${左右}.${上下係数}`,
            `UD${縦進捗}.${横進捗}.${左右}.${上下係数}`,
            `UD${縦進捗}.${横進捗 - 1}.${左右}.${上下係数}`,
          ];
        }
      });
    });
  });
});

const 柱YU = 腕縦.reduce((値, 値群) => Math.max(値群[1], 値), 0);
const 柱YS = 尻縦.reduce((値, 値群) => Math.max(値群[1], 値), 0);
const 柱YSS = 尻縦.reduce((値, 値群) => Math.min(値群[1], 値), 0);
const 柱KY = 柱YU - 柱YS;
const 柱KZ = Math.sin(柱.角度) * 柱KY;
[1, -1].forEach((左右係数, 左右) => {
  [0, 1].forEach((内外) => {
    Array(柱.解像度 + 1).fill(null).forEach((_, 柱進捗) => {
      const 角度 = Math.PI / 2 * (1 + 柱進捗 / 柱.解像度);
      const 距離Y = 柱.径 + (柱.径 - 柱.幅X * (1 - 内外)) * Math.cos(角度);
      const 座標X = (柱.横X - 柱.径 + (柱.径 - 柱.幅X * (1 - 内外)) * Math.sin(角度)) * 左右係数;
      const 距離Z = 柱KZ * 距離Y / 柱KY;
      coordinates[`柱${左右}${内外}${柱進捗}.1`] = { X: 座標X, Y: 柱YS + 距離Y, Z: 柱.下Z + 距離Z + 柱.幅Z / 2 };
      coordinates[`柱${左右}${内外}${柱進捗}.2`] = { X: 座標X, Y: 柱YS + 距離Y, Z: 柱.下Z + 距離Z - 柱.幅Z / 2 };
      if (柱進捗) {
        surfaces[`CH${左右}${内外}${柱進捗}`] = [
          `柱${左右}${内外}${柱進捗}.1`,
          `柱${左右}${内外}${柱進捗 - 1}.1`,
          `柱${左右}${内外}${柱進捗 - 1}.2`,
          `柱${左右}${内外}${柱進捗}.2`,
        ];
      }
    });
    const 座標SX = (柱.横X - 柱.幅X * (1 - 内外)) * 左右係数;
    coordinates[`柱${左右}${内外}SU.1`] = { X: 座標SX, Y: 柱YU, Z: 柱.下Z + 柱KZ + 柱.幅Z / 2 };
    coordinates[`柱${左右}${内外}SU.2`] = { X: 座標SX, Y: 柱YU, Z: 柱.下Z + 柱KZ - 柱.幅Z / 2 };
    coordinates[`柱${左右}${内外}SS.1`] = { X: 骨.上径 * 左右係数, Y: 柱YSS - 柱.幅X * 内外, Z: coordinates[`柱${左右}${内外}${柱.解像度}.1`].Z };
    coordinates[`柱${左右}${内外}SS.2`] = { X: 骨.上径 * 左右係数, Y: 柱YSS - 柱.幅X * 内外, Z: coordinates[`柱${左右}${内外}${柱.解像度}.2`].Z };
    surfaces[`CH${左右}${内外}SU`] = [
        `柱${左右}${内外}SU.1`,
        `柱${左右}${内外}SU.2`,
        `柱${左右}${内外}0.2`,
        `柱${左右}${内外}0.1`,
    ];
    surfaces[`CH${左右}${内外}SS`] = [
        `柱${左右}${内外}SS.1`,
        `柱${左右}${内外}SS.2`,
        `柱${左右}${内外}${柱.解像度}.2`,
        `柱${左右}${内外}${柱.解像度}.1`,
    ];
  });
});

const 脚外距離 = Math.pow(脚.外径 * 脚.外径 + 脚.外幅 * 脚.外幅, 1 / 2);
const 脚外角度 = Math.acos(脚.外径 / 脚外距離);
const 脚内距離 = Math.pow(脚.内径 * 脚.内径 + 脚.内幅 * 脚.内幅, 1 / 2);
const 脚内角度 = Math.acos(脚.内径 / 脚内距離);
Array(脚.数).fill(null).forEach((_, 脚進捗) => {
  const 角度 = Math.PI * 2 / 脚.数 * 脚進捗;
  [1, -1].forEach((前後係数, 前後) => {
    const 脚外X = Math.sin(角度 + 脚外角度 * 前後係数) * 脚外距離;
    const 脚外Z = Math.cos(角度 + 脚外角度 * 前後係数) * 脚外距離;
    const 脚内X = Math.sin(角度 + 脚内角度 * 前後係数) * 脚内距離;
    const 脚内Z = Math.cos(角度 + 脚内角度 * 前後係数) * 脚内距離;
    coordinates[`AS${脚進捗}.${前後}.GS`] = { X: 脚外X, Z: 脚外Z, Y: 脚.外位 };
    coordinates[`AS${脚進捗}.${前後}.GU`] = { X: 脚外X, Z: 脚外Z, Y: 脚.外位 + 脚.外高 };
    coordinates[`AS${脚進捗}.${前後}.NS`] = { X: 脚内X, Z: 脚内Z, Y: 脚.内位 };
    coordinates[`AS${脚進捗}.${前後}.NU`] = { X: 脚内X, Z: 脚内Z, Y: 脚.内位 + 脚.内高 };
    surfaces[`AS${脚進捗}.${前後}`] = [
      `AS${脚進捗}.${前後}.GS`,
      `AS${脚進捗}.${前後}.GU`,
      `AS${脚進捗}.${前後}.NU`,
      `AS${脚進捗}.${前後}.NS`,
    ];
  });
  surfaces[`AS${脚進捗}`] = [
    `AS${脚進捗}.0.GU`,
    `AS${脚進捗}.0.NU`,
    `AS${脚進捗}.1.NU`,
    `AS${脚進捗}.1.GU`,
  ];
  surfaces[`AS${脚進捗}S`] = [
    `AS${脚進捗}.0.NU`,
    `AS${(脚進捗 + 1) % 脚.数}.1.NU`,
    `AS${(脚進捗 + 1) % 脚.数}.1.NS`,
    `AS${脚進捗}.0.NS`,
  ];
});

const 骨下Y = 脚.内位 + 脚.内高;
const 骨上Y = 骨下Y + 骨.下高;
Array(骨.解像度).fill(null).forEach((_, 骨進捗) => {
  const 角度 = Math.PI * 2 / 骨.解像度 * 骨進捗;
  const 下X = Math.sin(角度) * 骨.下径;
  const 下Z = Math.cos(角度) * 骨.下径;
  const 上X = Math.sin(角度) * 骨.上径;
  const 上Z = Math.cos(角度) * 骨.上径;
  coordinates[`HN${骨進捗}SS`] = { X: 下X, Z: 下Z, Y: 骨下Y };
  coordinates[`HN${骨進捗}SU`] = { X: 下X, Z: 下Z, Y: 骨上Y };
  coordinates[`HN${骨進捗}US`] = { X: 上X, Z: 上Z, Y: 骨上Y };
  coordinates[`HN${骨進捗}UU`] = { X: 上X, Z: 上Z, Y: 0 };
  surfaces[`HD${骨進捗}`] = [
    `HN${骨進捗}SS`,
    `HN${(骨進捗 + 1) % 骨.解像度}SS`,
    `HN${(骨進捗 + 1) % 骨.解像度}SU`,
    `HN${骨進捗}SU`,
  ];
  surfaces[`HN${骨進捗}`] = [
    `HN${骨進捗}US`,
    `HN${(骨進捗 + 1) % 骨.解像度}US`,
    `HN${(骨進捗 + 1) % 骨.解像度}UU`,
    `HN${骨進捗}UU`,
  ];
});

Object.keys(coordinates).forEach((記号) => {
  coordinates[記号].X *= 2;
  coordinates[記号].Y *= 2;
  coordinates[記号].Z *= 2;
});

const colors = {
  default: '#ffffff',
  SE: '#444455',
  SI: '#444455',
  UD: '#444455',
  CH: '#666677',
  HN: '#bbbbcc',
  HD: '#666677',
  AS: '#666677',
};

const strokeColors = {
  default: '#000000',
};
